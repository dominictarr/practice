start
fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
	declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown-> just show configured one.
this is self parsing.because the code can just load.


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~
started using VIM. it's much faster than scit. 
although, I don't have line-goto on error output. but didn't work in scite either... 

fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.
what is the simplest which will work.

on(x).configure(


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~


writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.
what is the simplest which will work.

on(x).configure(


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~

fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc.defaults}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
.defaults means dont expand the tree of possibilities.

#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.-> only show configured one.
this is self-parsing because it uses just uses code... 
i've got a funny feeling this might be too clever in places.
use symbols in the configuration so you don't need to require everything.


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~

Sunday 16th, 18:03
deciding what to do next. i feel that a demonstratable prototype will be ready in a week or two.
it will have
	* configuration/composition generation
	* automatic interface testing
	* be able to load a new application composition.
but wont manage the path...

next problems:
	* composition datastructure.
	* interface test runner.
	* composition template builder
	? interface test database?... just serialize the whole Hash map or whatever?

~~~~~~~~~~~~~~~~~~~
process find classes with interface fast with a method -> [Class] map.
map of methods -> classes which support that method.
classes which implement an interface are 
union(*interface.each(|it| method_map(it)))
union returns the longest list which is a union of all arg lists.
~~~~~~~~~~~~~~~~~~~

interface test runner:
	1. find all tests.
	2. run all tests to discover all interfaces.
	3. check all classes and map interfaces to supporting classes
	4. wire supporting classes into tests and map interfaces to passing classes.
	?what about incompatibilities?
	5. parse application, generate composition, with suggestions from tester.

~-~-~-~-~-~-~
better tester which is compatible with all test frameworks.
...one not based on inheritence?
~-~-~-~-~-~-~

>ruby -I`pwd` -rubygems class_herd/interface_tester.rb class_herd/*.rb


about half the tests fail when wrapped in the VCR. this is essential, so maybe now is the time to work on the Interface Discovery.

have two ideas:
	1. alias every method on a class with a reporting method.
	2. use set_trace_func to watch calls without interferring.
	3. parse the test and see what methods it calls.
	
this doesn't #have# to be prefect - this detects which classes might be good to test, 
but it's okay if people claim thier class has an interface... and test that. 

2. seems more powerful, but, now that i've just looked into it, 1. seems simpler to implement.
3. would be simple, but wouldn't cover the cases where a class is passed somewhere else 
	and initialized there.

prodded 2. trace is massive, with many other calls you're not interested in. there are other similar problems which i have only just realized... what about the class calling itself?
i'd encounter implementaion methods not related to the interface.

maybe parsing is a good method? or parse the stacktrace, and see when the test object calls a 
method on the test class. if we 'tag*' the class of the new instance we should know exactly 
which object is the one we're after.
* by duplicating or subclassing...
argh. the trace function doesn't give you the method! how annoying is that? i'd have to parse it from the .rb file! (although, that is given).

sounds like alot of work. -> alias every method.


	   @#@#@#@#@#@#@#@#@#@#@#@
	   BIG IDEA: UNIVERSE GAME 

	      ~/~ "WIZARDS" ~/~

	   @#@#@#@#@#@#@#@#@#@#@#@

a game where the game is programming the game from inside the game.

the player is a magicial entity in the world made from
Earth, Air, Fire, Water and Magic.

everything in the game is made from these 5 elements. 
the first 4 are already existing and cannot be destroyed.
magic is created by wizards.

the simplest game object is a rock.
it's a lump with high earth, and low AFW.
wizards can give magic to things which allow them to use fire to do things.

fire is energy. if there is no energy, then no magic can happen.
water contains fire. something having water means it can contain more water and not burn.
water makes flexibility.
air gives lightness. things with air are easier to move. and easier to absorb.
earth is strength. it makes things hard and heavy.

dirt is earth with air.
add water and it becomes mud.
add fire and it becomes clay.

add the right magic and that clay comes to life.

make a clay plant by adding magic to tell the plant to absorb elements from the soil, and grow new parts.

the plant absorbs whats around it, and then grows seeds (tiny blobs of magic clay) and throws 
them away, to grow into more trees.

you could make animals, which move them selves, but need much more energy.
they would have to absorb energy from a place where it is more concentrated... i.e. plants.
or other animals.

wizards get more magical power when as more of thier magic happens. 
the speed they can rebuild magic and thier magical capacity is in proportion to how much
life they have created.

magic can affect magic, and copy itself. 
wizards could make a magic spell which copied itself.
life is a magic spell which controls material to gather enough energy to copy itself.

have to run game in the cloud and make it crazy scalable like katamari.

you could use magic to let your animals communicate. then you could build them into big 
ant-like hives. going out and finding things to eat. pulling them back to the hive, 
built out of big rocks pulled together...

I'm imagening ascii based rendering... but it wouldn't need to be directly tied to the game 
objects, it generate itself and you could zoom in and out... 
it would just give you a hint of what is happening...

to get things to be really cool, we need technology. for things to get way more efficant.

hmm. there could still be magic technology. better AI so that creatures could behave much more 
intelligently. or as a whole... that would all happen client side, anyway.

$$$$$$$$$$$$$$$$
or what about a pure software based game universe where the only limitation is memory and 
processors...hmm, you'd still need some way for wizards to earn more computer power.

and some challenge for them to accomplish...
$$$$$$$$$$$$$$$$


okay, i'm going to start work on the IDW.
aliasing each method is working, but discovering quirks. some methods will be aliased. 
some are inherited from superclass... 
-> will need to be defined, and super() called... class methods called in the wrapping method need to be handled specially. actually, it doesn't need to handle Object or class methods, because those are are going to be there always anyway.

it's looking pretty good with the little tests I have so far. 
ultimately, it should be able to wrap itself, and discover it's own interface!.

# it might be good to extend the class rather than dup it. that way, is_a? etc might still work.
#yup, that works for is_a?

#another way might to hook .class so it returns the duped class.

~~~~
running into problems from not having running all tests regularly.
monkey_patch/autorunner is interferring with this.
need a way to disable it, but reinable it too.

currently it's just disabled so that tests run.
TO RUN ALL TESTS
~/code/practice>ruby test_all.rb
~~~~

now back to IDW problem...
the test_interface_discovery is now passing.
but i've broken test_test_rewire. and test_test_interface has 2 fails.
hopefully i'll just need to fix tti.

ah, well I think the problem is the interface matching. 
I had underestimated that problem. I need to take into account different types of methods,
class methods, instance methods, private methods, methods which are only called internally.
also, it would be better to handle lists of methods as strings, because that is what 
Object.methods returns.

%%%%%%%%%
NAMING:
it's a bad idea to name something which isn't a unit test test_something,
and it's test test_test_something
if it tests something, but in a different way to a unit test, call them
something_tester, and test_something_tester...

%%%%%%%%
       #the problem here is, currently, Factors and FastFactors do not appear to have
       #the same interface. this is because fastFactors is written much better.
       #and does not call some of the internal methods which factors does. 
       #InterfaceDiscoveryWrapper isn't aware of this yet... and thus TestRewire refuses
       #to plug in FastFactors... so it runs only one test!
what is the next step?
I need interface testing fully working, so that plug in tests can run.
it seems interfaces is it.
is there anything else I should consider for Interfaces?

# what about wrapping something which is already wrapped?
  i.e. when you run interface discovery, on the interface discovery test?
# constants which arn't classes.
# modules.
# getting the interface functions, rather than the internal implementation functions.
# check arity.
# interface_testing depends on parsing. currently sexp_process fails if it sees a cfunc.
	-which it encounters when testing test_test_interface.
# test_v_c_r gives this: TypeError: wrong instance allocation
    /home/ubuntu/code/practice/class_herd/test_v_c_r.rb:83:in `new'
#still some lagging comparison problems. -- methods i don't usually use.
	- try testing class_conductor.
~~~~~ THATS ABOUT IT!

okay... first, fix sexp_processor?
ah, turns out Sexp_Processor has a setting. problem is in Unified ruby. tried setting setting. 
whole can of worms. took out unified ruby. tests all pass the same.

the cfunc problem in tti has turned into cannot find class 'AssertionFailedError'
might be helpful if class finder told me. this cfunc problem goes all the way down...
maybe better to ignore anything under cfunc?

look into this tomorrow.
