start
fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
	declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown-> just show configured one.
this is self parsing.because the code can just load.


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~
started using VIM. it's much faster than scit. 
although, I don't have line-goto on error output. but didn't work in scite either... 

fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.
what is the simplest which will work.

on(x).configure(


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~


writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.
what is the simplest which will work.

on(x).configure(


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~

fri May  6 07:49:46 UTC 2010

oops. i forgot to install ruby. messed about a little trying to copy it from other partition... but also very tired. try taking a nap frist.

writing business play might be more effective than coding today (am on train, unconnected from web)
stop
8:32

satuarday 17:02 pm

working on test_test_rewire 
known problem with vcr.==... investigating similar problems.
trying wrapping on other tests.
test_class_sub failed
	problem is: test sub has other classes defined in the same file (which confuses it) 
	class parser doesn't take modules yet. it will need to.
	probably the parser returning module::class would give it a better interface anyway.

i need a diagram of the classes here.

~~~~
idea, consistant interface for dealing with tabs in different tab based applications...
same shortcut keys

or popup window to cycle through like alt-tab, but in 2 dimensions... 
up and down between programms left and right between tabs.

what about set up shortcut keys to be:
[WIN+ up/down] change between programmes.
[win + left/right] change between tabs.

would be cool to have a screen which poped up to show where your going 
but this is good for now.

behaviour of ubuntu isn't ideal for this... will have to set shortcuts in each program. 
don't know how to do that in scite or chrome
~~~~


idea for new parsing system.

DSL which uses, a schema and flattens the data structure to match.

a schema has a tree structure itself:
[:class :lit [:call {call_block}]]
this means: for class, collect all :lit groups, and all :call groups. and process all call blocks with call_block
the processor will look into all groups, and if it encounters a group with a block exec the block, passing it the group.

it will flatten the tree  and just retain the groups named at that level.
if there is a sub group, it will process groups under that with the rule defined in that group.

the nestedness of the groups defines how much structure you want to retain.

[:class :lit :str] -> retrive a list of all literals and strings under class.
[:module [:class :lit :str] -> classes listesd under modules
[:module :def :const [:class :def]] -> get def's and const's, :class's under module, and :def's under class

definitions can be recursive:
c = [:class :def]
x = [:module :def 
c << c
x << c << x
[:module :def [:class :def [...]] [...]]

this is really tricky because sometimes the tree structure is partially flattened.
... hmm, the structure of the output matches the structure of the schema.

what about the structure of the process?...
	...when the output is flat...the process should be flat?
	what does code which parses a nested structure into a flat one look like?

write 
code to make a nested structure falt
and then seperate
code to copy a nested structure.

eventually got this working, and then realized that it didn't actaully have useful features.

monday 12:51 am. 

[made notes on docs.google.com]
plan for next step:
I need most to parse classes.
decide what format is best for test_rewire
rewrite parsing code to use ParseTree & classes.

monday 22:52
rewritten the class parsing class. 
I was very quick this time!
written test_rewire2 
given a test and classes, dynamicially tries whatever combinations of
classes it thinks it can plug in.

TODO: 
further testing of test_rewire. 
	another simple class.
	a test which uses two classes.
write something to test all the classes in the project.
rewrite interface discovery wrapper (VCR) IDW?
test whether shadowing also works for builtins i.e. Array.
make web end for test results.
~~~~
2nd level tests: substitute X into Y.x, and then test Y with the tests Y passes with defaults.
if X doesn't break Y's tests then great!
start by substituting things which pass the tests of Y.x, and have the interfaces.
~~~~

have written Factors (which uses Primes) and caluclates the factors of any number.
it makes another simple class for test_rewire.
the test could inject Primes also.

tuesday 0:34 am 11/5


started about 7ish?

today got test_rewire2 working with multiple substitutions.
1.need to tidy up the test running code. it's been duplicated. 
2.need a tight little class with good printing methods
	from full debug information to just a note to silent.
3. silence automatic running from test/unit.
4. write better Interface Discovery Wrapper

wednesday 1:38

wednesday 11:47 just a bit of quick coding to make test running class

started copying and pasting test runing code into new class, and discovered that 
I had a fail in TestTestRewiring.test_factors and TestTestRewiring.test_primes...
I used git to step back and found I had already had the error.

will work on car, and fix this later.

~~~~~~~~~~~~~~~~
idea: simple IDE in browser which completely handles versioning and libraries.
make it easy for teenagers to produce code.
aim is to move empasis to intelligence rather than knowledge.
so that they are not held back by setting up libraries etc.
~~~~~~~~~~~~~~~~


stop about 12:45
start again 13:25
~~~~~~~~~~
idea:
TestData should capture all output when it runs a test. 
as this could be useful for debuging
probably use a logging package.
~~~~~~~~~~
there is a problem with test... fixed

TODO: code to check the structure of an array tree

wednesday 3:52
monkey patched test/unit/autorunner so that it doesn't run all the test classes I create.
now I need a command to run a test though. or maybe a way to sign a test that it is not 
to be automaticially ran? while i'm still developing i'll want to use normal tests.

wednesday 22:55 
tests sorted out.
if I want to run just one test use command rtest - it suppresses AutoRunner
otherwise just ruby the test and it will autorunner.

~~~~~~~~~~~~~~~~~~~
set_trace_func ~ tells you so much that happens in the tests. it's going to be very useful.
maybe for interface discovery.
definately for code metrics.
maybe for evaluating contribution proportion.

wow, you can get the binding and the object_id
I wonder if that is enough data to reproduce an error?
maybe if you have a debug mode which hooks
bindings and objects at the start of a call...

is this stuff threadsafe? I don't see any mention of 
threads. hopefully this stuff still works, but only for 
the current thread.
~~~~~~~~~~~~~~~~~~~
what next?
code to run all tests on all classes in a project?
start looking into how I might run a class manager server? 
	- no can wait until configuration is happening.
parse configuration from every file in a project and graph how they fit together?
	- how to display configuration?
	- i'd need an example program to reconfigure.
	- just something structure which showed the layers of dependencies and
		what could be pluged in there?
		
i found how to load the contents of a directory:
Dir.new(path).entries
also, saw something interesting in test/unit
seting the types of arguments with the syntax:
file =::File
could this be developed further to specify essential tests?

thursday 14:16
write code to run all tests in a directory.
spedify a directory,
require each .rb file 
find all the tests and classes in specific modules.
(m = Module.const_get(:Test)).constants.select{|it| m.const_get(it.to_sym).is_a? Module}
run tests on them.
report on interfaces, and successful substitutions

maybe now is time to start thinking about how composition will work.
or write a few utils for the above idea?
ah, for this problem, i'm at the prodding it with a stick stage.
~~~~~~~~~~~~~~
we're going to want some nice visualization stuff
that will mean some facinating graph problems - and 
graph display problems too.
~~~~~~~~~~~~~~
PROBLEM: i've monkey patched class to add methods of checking equality ignoring whether it's a duplication
... but i've realized that Module doesn't inherit from Class (otherway around) 
so i've added a check in Class.equals? to return false if other isn't a Class

...I will probably want to change this when I code rewiring for Modules.
can print all modules with
experiments/print_module.rb [Module]
provide base module name as argument.
i've added require's for some of my stuff.

whats next?
hmm...

do the same thing with class references?

that is done now also.
what about something which can answer what .rb a class is in? will need that to load a configuration.
~~~~~~~~~~~~
datastructure representing a rewiring.

just serialze the _on.replace etc?
store those instructions in a datastructure?
then you wouldn't have to serialize the rest of the class info. ~does that matter yet?
~~~~~~~~~~~~
@@@@@@@@@@
using reconfigurations as a class - load them like another class - and run tests on them.
what about producing a .rb file which generated the class with ClassConductor::_on...etc and required the necessary files.
maybe identify a class version by a hash of thier sexp. that way you know your getting exactly the right one.
@@@@@@@@@@
############
what if you removed require's altogether, and the software was clever enough to figure out what was required.

can infur the interface, and use tests* to decide which classes, and then follow it down until you get to everything. 
challenging but possible. *think testing should be integrated into the language.
maybe this can be done for the web IDE.
############

okay, directory parser => source file lookup.
iterate through subdirectories.
parse each .rb file. -> discover modules, classes, 
(and require's for each file? ->that a whole can of worms to do properly, interfacing with rubygems.)
but could discover modules and classes.

~~~~~~~~
parsing everything  in the load path i've found a few unusual cases

/usr/lib/ruby/1.8/cgi.rb cant load /usr/lib/ruby/1.8/cgi.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/delegate.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/optparse.rb -> Expected :colon2 or :const but found self
cant load /usr/lib/ruby/1.8/tempfile.rb -> Expected :colon2 or :const but found call
cant load /usr/lib/ruby/1.8/timeout.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/rubygems.rb -> Expected :colon2 or :const but found colon3
cant load /usr/lib/ruby/1.8/digest.rb -> Expected :colon2 or :const but found colon3

it's all superclass stuff. I don't need to know superclass right now. shall I just ignore this?
(I'll need superclass if I am to parse the supported interface from the code ~that is quite advanced for now)
~~~~~~~~

!!!!!!!!!!!!!!!
I now have requirements to write a command
which parses a rb file and it's dependencies... 
then generates a rb file which includes all necessary rb's and the structure of the class.
hmm. this really needs to be updated live, incase you plug in something which has different sockets.
or re-read and updated? that means it needs to be reparsed.

brings me back to the datastructure idea.
on(x).replace(:y, z = on(Z).replace(etc)).replace(:s,z)

make a data structure, and output a new one when you update.
the data structure needs local variables.
doing it in ruby code would be nice, because then there is not new syntax to learn.
familiar error messages.

what about a tree of possibilities, 
with marks on the chosen.
on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc.defaults}
#name things
declare something: use(c).name(:name) 
refur to something: use_named(:name)
special dependency: .require(...)
.defaults means dont expand the tree of possibilities.

#otherwise use parsed classes automaticially.
}

will it get super crowed with sub trees shown.-> only show configured one.
this is self-parsing because it uses just uses code... 
i've got a funny feeling this might be too clever in places.
use symbols in the configuration so you don't need to require everything.


~~~~~~~~
idea: interactive console which is more like editing a file... when you go up, you are undoing the 
lower commands, but response is immediate, like a console.

might be easy with a functional language.
~~~~~~~~

Sunday 16th, 18:03
deciding what to do next. I feel that a demonstratable prototype will be ready in a week or two.
it will have
	* configuration/composition generation
	* automatic interface testing
	* be able to load a new application composition.
but wont manage the path...

next problems:
	* composition datastructure.
	* interface test runner.
	* composition template builder
	? interface test database?... just serialize the whole Hash map or whatever?

~~~~~~~~~~~~~~~~~~~
process find classes with interface fast with a method -> [Class] map.
map of methods -> classes which support that method.
classes which implement an interface are 
union(*interface.each(|it| method_map(it)))
union returns the longest list which is a union of all arg lists.
~~~~~~~~~~~~~~~~~~~

interface test runner:
	1. find all tests.
	2. run all tests to discover all interfaces.
	3. check all classes and map interfaces to supporting classes
	4. wire supporting classes into tests and map interfaces to passing classes.
	?what about incompatibilities?
	5. parse application, generate composition, with suggestions from tester.

~-~-~-~-~-~-~
better tester which is compatible with all test frameworks.
...one not based on inheritence?
~-~-~-~-~-~-~

>ruby -I`pwd` -rubygems class_herd/interface_tester.rb class_herd/*.rb


about half the tests fail when wrapped in the VCR. this is essential, so maybe now is the time to work on the Interface Discovery.

have two ideas:
	1. alias every method on a class with a reporting method.
	2. use set_trace_func to watch calls without interferring.
	3. parse the test and see what methods it calls.
	
this doesn't #have# to be prefect - this detects which classes might be good to test, 
but it's okay if people claim thier class has an interface... and test that. 

2. seems more powerful, but, now that i've just looked into it, 1. seems simpler to implement.
3. would be simple, but wouldn't cover the cases where a class is passed somewhere else 
	and initialized there.

prodded 2. trace is massive, with many other calls you're not interested in. there are other similar problems which i have only just realized... what about the class calling itself?
i'd encounter implementaion methods not related to the interface.

maybe parsing is a good method? or parse the stacktrace, and see when the test object calls a 
method on the test class. if we 'tag*' the class of the new instance we should know exactly 
which object is the one we're after.
* by duplicating or subclassing...
argh. the trace function doesn't give you the method! how annoying is that? i'd have to parse it from the .rb file! (although, that is given).

sounds like alot of work. -> alias every method.


	   @#@#@#@#@#@#@#@#@#@#@#@
	   BIG IDEA: UNIVERSE GAME 

	      ~/~ "WIZARDS" ~/~

	   @#@#@#@#@#@#@#@#@#@#@#@

a game where the game is programming the game from inside the game.

the player is a magicial entity in the world made from
Earth, Air, Fire, Water and Magic.

everything in the game is made from these 5 elements. 
the first 4 are already existing and cannot be destroyed.
magic is created by wizards.

the simplest game object is a rock.
it's a lump with high earth, and low AFW.
wizards can give magic to things which allow them to use fire to do things.

fire is energy. if there is no energy, then no magic can happen.
water contains fire. something having water means it can contain more water and not burn.
water makes flexibility.
air gives lightness. things with air are easier to move. and easier to absorb.
earth is strength. it makes things hard and heavy.

dirt is earth with air.
add water and it becomes mud.
add fire and it becomes clay.

add the right magic and that clay comes to life.

make a clay plant by adding magic to tell the plant to absorb elements from the soil, and grow new parts.

the plant absorbs whats around it, and then grows seeds (tiny blobs of magic clay) and throws 
them away, to grow into more trees.

you could make animals, which move them selves, but need much more energy.
they would have to absorb energy from a place where it is more concentrated... i.e. plants.
or other animals.

wizards get more magical power when as more of thier magic happens. 
the speed they can rebuild magic and thier magical capacity is in proportion to how much
life they have created.

magic can affect magic, and copy itself. 
wizards could make a magic spell which copied itself.
life is a magic spell which controls material to gather enough energy to copy itself.

have to run game in the cloud and make it crazy scalable like katamari.

you could use magic to let your animals communicate. then you could build them into big 
ant-like hives. going out and finding things to eat. pulling them back to the hive, 
built out of big rocks pulled together...

I'm imagening ascii based rendering... but it wouldn't need to be directly tied to the game 
objects, it generate itself and you could zoom in and out... 
it would just give you a hint of what is happening...

to get things to be really cool, we need technology. for things to get way more efficant.

hmm. there could still be magic technology. better AI so that creatures could behave much more 
intelligently. or as a whole... that would all happen client side, anyway.

$$$$$$$$$$$$$$$$
or what about a pure software based game universe where the only limitation is memory and 
processors...hmm, you'd still need some way for wizards to earn more computer power.

and some challenge for them to accomplish...
$$$$$$$$$$$$$$$$


okay, i'm going to start work on the IDW.
aliasing each method is working, but discovering quirks. some methods will be aliased. 
some are inherited from superclass... 
-> will need to be defined, and super() called... class methods called in the wrapping method need to be handled specially. actually, it doesn't need to handle Object or class methods, because those are are going to be there always anyway.

it's looking pretty good with the little tests I have so far. 
ultimately, it should be able to wrap itself, and discover it's own interface!.

# it might be good to extend the class rather than dup it. that way, is_a? etc might still work.
#yup, that works for is_a?

#another way might to hook .class so it returns the duped class.

~~~~
running into problems from not having running all tests regularly.
monkey_patch/autorunner is interferring with this.
need a way to disable it, but reinable it too.

currently it's just disabled so that tests run.
TO RUN ALL TESTS
~/code/practice>ruby test_all.rb
~~~~

now back to IDW problem...
the test_interface_discovery is now passing.
but i've broken test_test_rewire. and test_test_interface has 2 fails.
hopefully i'll just need to fix tti.

ah, well I think the problem is the interface matching. 
I had underestimated that problem. I need to take into account different types of methods,
class methods, instance methods, private methods, methods which are only called internally.
also, it would be better to handle lists of methods as strings, because that is what 
Object.methods returns.

%%%%%%%%%
NAMING:
it's a bad idea to name something which isn't a unit test test_something,
and it's test test_test_something
if it tests something, but in a different way to a unit test, call them
something_tester, and test_something_tester...

%%%%%%%%
       #the problem here is, currently, Factors and FastFactors do not appear to have
       #the same interface. this is because fastFactors is written much better.
       #and does not call some of the internal methods which factors does. 
       #InterfaceDiscoveryWrapper isn't aware of this yet... and thus TestRewire refuses
       #to plug in FastFactors... so it runs only one test!
what is the next step?
I need interface testing fully working, so that plug in tests can run.
it seems interfaces is it.
is there anything else I should consider for Interfaces?

# what about wrapping something which is already wrapped?
  i.e. when you run interface discovery, on the interface discovery test?
# constants which arn't classes.
# modules.
# getting the interface functions, rather than the internal implementation functions.
# check arity.
# interface_testing depends on parsing. currently sexp_process fails if it sees a cfunc.
	-which it encounters when testing test_test_interface.
# test_v_c_r gives this: TypeError: wrong instance allocation
    /home/ubuntu/code/practice/class_herd/test_v_c_r.rb:83:in `new'
#still some lagging comparison problems. -- methods i don't usually use.
	- try testing class_conductor.

~~~~~ THATS ABOUT IT!

okay... first, fix sexp_processor?
ah, turns out Sexp_Processor has a setting. problem is in Unified ruby. tried setting setting. 
whole can of worms. took out unified ruby. tests all pass the same.

the cfunc problem in tti has turned into cannot find class 'AssertionFailedError'
might be helpful if class finder told me. this cfunc problem goes all the way down...
maybe better to ignore anything under cfunc?

look into this tomorrow.

$$$$
made a test to see if IDW could wrap itself.
it could. i was expecting it to fail. it looks like .methods does not return aliased methods.
interface testing test_test_interface still fails in a infinite loop / stack overflow.
	- maybe this is double wrapping. YUSS. error reproduced!
	
method is aliased, and then the alias is aliased.
but if a old new method calls another aliased method, 
the old new method now refurs to the new new method.

what if I create a special alias for those methods, and then check that it's there and do not alias it.

what if you alias x2, x
redefine x',
and then alias x3, x
and redefine x''.
what method does x2 call?
x, or x''?
it could still call x.

hmm. I hook 'method' but when I call the hook it calls method, and if I redefine 'method' it calls the redefined method.

added tests to check for double wrapping and self-reference to test_interface_discovery, 
it's passing but that doesn't mean i can run interface_tester on it. 
the error goes all the way down. 

all the way down the infinite stack of giant turtles which hold up the flat earth.

VERY interesting error for class references:

t_innerclasses() [/home/ubuntu/code/practice/class_herd/test_class_references.rb:41]:
<:OuterClass> expected but was
<:"UnnamedClass_-610610048">.

ClassReferences4 has parsed a class, and found a reference to something that has been duped...
will class finder be able to find one of these?
do i need to name them and put them somewhere?
ClassReferences4 is a dependency for TestInterface. so this error will be causing problems there also.

HOW TO MAKE AN ANON CLASS INTO A REAL CLASS:
assign it to a constant.

class Mini; end
Mini.name
=> "Mini"
m = Class.new(Mini)
=> #<Class:0xb76f2bd0>
m.name
=> ""
 Mini_1 = m
=> Mini_1
irb(main):072:0> m
=> Mini_1
irb(main):073:0> m.name

I know this will be important. but I don't know what I will do with this information yet.
	? Modify the class making code so that ClassFinder can find it?
	then I could get test_class_finder flexible enough to pass wrapped?
	
	then TestTestInterface might work wrapped.

	I only just learned you could do this and what to do with it.

	my head is spinning.

	prehaps the thing to do is testing class finder. I don't really know what
	class finder needs to do yet. 
	what about :
		1.take any class.
		2.modularise it=> find all references, rewire them.
		3.reparse it, and remap everything again.
		4.be able to do the above, but also do it for all sub-parts recursively.

	I can stick the duplicated classes in a module. 
	but I dont know how to decide where to put them yet.

	hey! this is related to the problem of how to manage the source files on the server.

	okay, make a ClassCopier which controls the duping of classes.
	then add it into IDW, and ClassConductor3.
	hmm. have	

~~~~~~~~~~~~~~~~~~~~~
NEW CONCEPT NAMED: "Flexible Ontology" 

contrast to "Rigid Ontology"
............
a rigid ontology is defined according to a hierachical structure.
i.e. a duck is a aquatic bird with a round bill

(animal (bird (freshwater (rounded bill))))

vs.

if it walks like a duck (waddles)
and
if it talks like a duck (quaks)

it = a duck.

i.e. in a flexible ontology, classification of objects is 
according to wether they pass tests.

another example:
what is a public utility?
if X is NOT a public utility then the phrase
"millions of children in africa have no access to X" sounds like a joke.

public utilities:
running water
health care
schooling
a library

not public utilities:
facebook
youtube
fake vomit
cheap beer

wikipedia?... that isn't clear really. 
wikipedia isn't quite as reliable as a library yet.
..............

A difficult problem in the classification of objects is dealing with things
like fictional characters.
how much does santa clause weigh?
acceptable answers: about 300 pounds. 0 (he does not exist)

is a doll's house a building?
or a model building?

certain tests can be ignored in certain contexts.

on a page of a children's book, a picture of an apple is 'an apple'
if you are hungry, it is only 'a picture of an apple'
............
this feels simple enough to implement.

build a robot you can read a children's story to...
............
ask it a question, like "how many people has arnold swartezenigger killed?", or "how old is bart simpson" and it can
answer in a sensible way.

might even be able to give it a sense of humour.
~~~~~~~~~~~~~~~~~~~~~


20th may, 3:27
wrote class_copier
test that copies and has the same behaviour, and that comparison functions behave properly
test passes.

still fails for interface_tester. but thats probably because i_t doesn't use class_copier.

class_copier is probably going to be the first test which i will use for multiple classes.

a real situation for rewiring, - not a toy example.

everything for class copy should apply to interface wrapper also!

~~~~~~~~~~~~~~~~~~~
$ HANDLING SUPER CLASS METHODS AND VARIABLES

how does access to settings defined in a super class work?
~~~~~~~~~~~~~~~~~~~

options on copier to say where to put the created classes, and to remove them when you've 
finished with them. i.e. interface discovery wrappers don't need to still exist after the 
test has finished. or maybe they could be kept somewhere sensible?

REFACTOR ClassConductor and InterfaceDiscoveryWrapper

class copy doesn't pass the interface test - problem caused by X not equal X'' 
(X'' is X wrapped twice)

hmm. more robust way to check for equality or classes?
what about, if your coping a copied class, set @duped to original.@duped


~/~/~ TEST RESULTS ~/~/~

test_class_copy passes interface_tester!!!

test_references still fails because the test is too hard-wired.
soft-wiring it's working, but there is also the problem of class_references returning things which arn't classes. and all the core classes (which end up in tests...) which are not necessary.

	several errors like:<:"ClassHerd::TestClassSub"> expected but was
	<:"ClassHerd::ClassCopier::TestClassReferences_cc1::TestClassSub">.
	should I hook class name to fix this so that wrapping a class
	still gives the name of the class the wrapper is pretending to be?

	I feel like this is going one step too far, but i'll try it and see what happens.

	two problems remaining:
		1. class_references returns local reference names. i.e. they dont have 
		the module if they dont need it.
		2. when class_references is running in test_interface it returns different
		references.
		[3, i remember now that i've fixed it. class references returns all Constants 
		even if they are not classes] 
		1 = easy, 2 = hard.

		2 also causes errors in test_file_explorer
		
suspect problem caused by class_conductor affecting parsing.

		1 is fixed.
################
parsing seems to be causing slowness. 

idea: hook require and do the parsing then. dont do it again later...
also, make a smart way to just parse the changes in copied classes.
################


problem 2:
test is parsed,
figured out problem class references being wrapped while performing self reference.
GOT A SIGNAL!
class references gets a different parse when target class is wrapped by IDW.
theory: it also parses the super class.
experiment: vary the target class, and the wrapping method.

ClassCopy works sweet.
ClassConductor is not compatible with String.
InterfaceDiscoveryWrapper adds elements even with EmptyClass.

                    ##}Sneaky Idea{##
if a class is duped parse the original class (side step problem...)
-----------------------------------------------------------------------
where does this extra stuff come from? 

when you alias a method, it adds two copies of that 
method into the class. then if you define a new method you have that as well! 
that empty class becomes huge file because IDW hooks all of Object's methods. 
no wonder it runs slowly.

if the your wrapping a test: which happens when your testing a meta-tester. 
then alias_method copies all the methods from TestCase... and pulls in thier references.

also, for String ClassConductor3 failed because of added stuff...

maybe there is quite alot of room for improvement here.

maybe, redefine all the methods, and then only hook missing method?
maybe don't wrap Object methods (every object will have them, 
so it's not important to check if they are in the interface.)

handle subclass methods differently,
just defining a new method, and calling super.
------------------------------------------------------------------------

IMPLEMENTED SNEAKY SOLUTION.
it works.
fixed class reference returning non class references.

ran interface_tester:

1 fail 20 errors (out of 144 tests)

the two biggest baddies:
1.
test_with_primes1(ClassHerd::TestTestRewiring):
NameError: uncaught throw `invalid_test'

(occurs in test_test_interface also)
2.
and stackover flow in test_interface_discovery

    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:86:in `idw_special_add_method'
    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:55:in `interface'
    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:88:in `idw_special_add_method'
    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:86:in `each'
    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:86:in `idw_special_add_method'
    /home/ubuntu/code/practice/class_herd/interface_discovery_wrapper.rb:55:in `wrap'
    /home/ubuntu/code/practice/class_herd/test_interface_discovery.rb:10:in `test_simple'

1. test_* methods now apparently have arity = 1. which makes them not tests. this must becaused by IDW. - made a test for this and reproduced this error.

XXX
having IDW map wrapped classes to interfaces is problematic for wrapping something twice...
change it to map from original class.

@@@@@@
argh. found the cause of the interface_discovery stack overflow error. 

is caused by test_self_reference. if test_self_reference is included, EVERY test_* method gets the stack overflow.
including one test causes other tests to fail!
thats a weird problem.

okay! i've reproduced the error!
It's caused by a wrapping a wrapped idw class, with wrapped IDW instance
fixed it! aliased 'interface' and named one 'idw_special_interface' so that it doesn't get wrapped. 
I didn't even have to fully understand the problem there, I just guessed.

okay, next problem is arity...
rewrite the wrapping method so it preserves arity.
-done

monday 24 may.
then wrapped no all interface methods are returning the right stuff. run interface_tester test_test_interface

tuesday 25th, 13:01
In auckland.

I've got just a few errors left. something about interfaces. I think I need to overhaul the interface checking system.
i had made an interface class for representing that... but hadn't used it. it's not tested, because i've already used 
the name test_interface for something else.... time to refactor all those names...

wednesday, 26th, may.

refactored the logging (puts's) in interface_tester and interface_test_runner. given some clarity it became obvious 
where the problem is. sometimes test interface is not actually getting the methods.

normal interface tests run fine, but running test_interface_tester through interface_tester can't see doesn't 
end up seeing the methods which get called. although the tests still pass. (although it works on test primes)

2 ideas:
	1.the methods are ending up somewhere else.
	2. the wrapped objects are not actually being initialized.
	
	approches:
	1.ObjectSpace the IDWs and query which what interfaces they know.
	2.ObjectSpace the wrappers and check they are initialized.
	****************
	aha! interface_tester is not actually inserting the wrapped classes when it is itself running in the interface_tester!
	****************
	okay, so I vaguely know where this error is located. i've considered that possibly fixing it isn't necessary right now.
	testing the meta code on it self is a good test of it's robustness, but at the prototype stage high robustness 
	isn't essential.
CURRENT ERRORS.
	1.test_interface_tester testing it self fails to handle assign rewires properly.
	2.interface doesn't distinguish internal methods. which will cause incompatiblity. 
		maybe only record methods from a specific caller/.rb? i.e. the test?
	3. test vcr - wrong instance allocation. not sure what this is but another thing i don't use anymore.
	
NEXT STEPS:
	1.composition layer.
		- parse the default structure from a given application, output a convient editable format (yaml)
		- and allow it to be reconfigured... 
		- command to run a configuration.
	2. module server.
		- store all information on tests, 
		- receive new classes
		- provide interface for editing compositions.
		- show test data for a given composition
		- other possibilities for given modules
PLAN
	write a basic composition layer, then use that to build the module server.
	want to edit the code for the server interactively. have interface customized per user.
	but even be able to edit whole server. that means that a program can have more than one composition layer.
	like the interface, ontop of the server. to an unprivilged user, the server appears to be a platform. 
	multiple platforms - a ziggurat 
	
	
COMPOSITION

	use a format so that it will come out well when converted to YAML.
	notes from last time I thought about this:
	on(x){:A => suggested(a,b,c,d).use(c){:symb => blah, etc.defaults}
	
	use lists and maps for yaml.
	{use: InitialClass
		Symbol: ClassToUse
		AnotherSymbol: {use: SuchAndSuch
					Symbol: ReplacementSym 
						#use replacement_sym instead of Symbol on the SuchAndSuch
						#which is used instead of AnotherSymbol on InitialClass}}
when you load a Composition
you can query the classes and check the structure, 
and create a new instance. hmm.

Composition represent the "wiring" of an Application.
an Application is a set of classes without outside dependencies.
it could be one class or many.

I need a convient Class method to retrive the "wiring" of a class. 
that includes default wiring, and rewiring.

this problem is more sophisticated than I first realized.
for example, what happens when a class refurs to it self?
should I implement as simply as possible or attempt a real 
implementation to get a feel for the problem?

attempt REAL IMPLEMENTATION

second attempt ran into problems with self reference.
printing causes stack overflows, etc.

the built in classes handle self reference so I realized that 
the correct method is to use builders to create a data structure
from basic types. Hashes I guess.

builder to make composition from use, replace etc.
builder to make composition from given class
builder to make classes from composition

problem with array ==. 
array == is confused if there is cyclic membership.
yaml handles this though 
- so can convert to yaml and check that.

NEXT: create classes from composition datastruct.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
On The Horizon.
composition editor which allows others to extend, 
and rewire compositions. and leave a few sockets open...
and maybe configure settings on classes once they are initialized.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

###########################
Predictive Text System for Chorded keyboard.

if they keys are layed out well, then a predictive system could 
eliminate the need for chording. the T9 system on cell phones.
the predictive texting on my phone is annoying. 
but i've often said I could write a better one.

(wireless) numeric keypad turned on it's side. 

3 * 4 = 12 letter keys. 2 letters per key for 10 keys, and two 3 letter keys.
and symbols <>{}[]()"' ,./?:;!@#$%^&*_+-= -~` = 29
thats 10 enclosing symbols <>{}[]()"'
~ about 3 symbols per key.
+ numbers = 10.
how many shift keys:
letters2, enclosing_symbols, symbols2, symbols3 (symbols 1+2), numbers

or use multi presses to get the second layer of rarely used symbols.

simple predictive:
just use contextual analysis of the last few letters to guess the next one.
press a cycle button change between different possibilities for the last word.

(for example, my phone predicts bucklame when I try to type auckland.
buck seems more likely than auck but if I correct it a few times. 
it should just give me auckland. also, I should be able to press cycle to get
other possible completions.
with only 2 letters per key prediction will be easier, and with letters unlikely 
to share a context will make prediction easier.
###########################



Composition.
encountered errors building composition from Object
other Core classes create more complexity also. 
time to make settings for limiting composing from a class?


############
found a bug in ParseTree.
NoMethodError: undefined method `-' for nil:NilClass
when you try and parse Object.
parse_tree.rb line 21:
    a[1..a.index(superclass)-1]
but a.index(superclass) is nil.

also there is a bunch of other weird shit when you parse Object.
- in the actual sexp's. 
I don't really want to rewire Object 
instead write stuff to limit extent to composing.
i.e. when you get to core classes, just stop.
############

way to specify defaults?
	- Composition3.new.defaults(classes)
	will have to change Composition3 to lazy initialize so it has time to recieve the defaults.
	things that appear in the default list, are not broken down any deeper.
	OKAY. I got composition working, loading classes. stopping at defaults.
	I want t really dramaticly big class structure to read.
	and to test that the structure would build a class tree which is the same as before.
	and that the new class tree reads into the same composition.
	
	I have discovered 2 new errors in ClassHerd::TestClassCopier. - FIXED
	also, i've re defined Class._rewires so that TestInterfaceDiscovery doesn't work any more.
	 - FIXED
	 
	monday may 31.
	
	TestInterfaceWrapper is going into an infite loop
	Compostition3 on RewiringTester -> uninitialized constant ProcWrapper.
		(this is a problem in class finder)
	NEXT: 
		1. fix these errors, 
		2. test reconstrructing classes from compositions.